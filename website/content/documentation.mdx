---
title: "domet ・ /ˈdɔ.met/"
description: "A lightweight scroll spy hook for React"
---
<Demo src="examples/basic" caption="A quick example demonstrating how easy it is to use" />

domet is a lightweight React hook built for scroll-driven interfaces. Use it for classic scroll-spy, but also for progress indicators, lazy section loading, or any UI that needs reliable section awareness.

Lightweight under the hood: a tight scroll loop and hysteresis for stable, flicker-free section tracking.

For the source code, check out the [GitHub](https://github.com/blksmr/domet).


## Installation ++Requires React 18 or higher++

```bash
npm install domet
```

## Quick Start

```tsx
import { useDomet } from 'domet'

const sections = ['intro', 'features', 'api']

function Page() {
  const { activeId, sectionProps, navProps } = useDomet(sections)

  return (
    <>
      <nav>
        {sections.map(id => (
          <button key={id} {...navProps(id)}>
            {id}
          </button>
        ))}
      </nav>

      <section {...sectionProps('intro')}>...</section>
      <section {...sectionProps('features')}>...</section>
      <section {...sectionProps('api')}>...</section>
    </>
  )
}
```


## API Reference

### Arguments

<PropTable items={[
  { name: "sectionIds", type: "string[]", description: "Array of section IDs to track" },
  { name: "containerRef", type: "RefObject<HTMLElement> | null", default: "null", description: "Scrollable container (defaults to window)" },
  { name: "options", type: "DometOptions", default: "{}", description: "Configuration options" },
]} />

### Options

<PropTable items={[
  { name: "offset", type: "number", default: "0", description: "Trigger offset from top in pixels" },
  { name: "offsetRatio", type: "number", default: "0.08", description: "Viewport ratio for trigger line calculation" },
  { name: "debounceMs", type: "number", default: "10", description: "Throttle delay in milliseconds" },
  { name: "visibilityThreshold", type: "number", default: "0.6", description: "Minimum visibility ratio (0-1) for section to get priority" },
  { name: "hysteresisMargin", type: "number", default: "150", description: "Score margin to prevent rapid section switching" },
  { name: "behavior", type: "'smooth' | 'instant' | 'auto'", default: "'auto'", description: "Scroll behavior. 'auto' respects prefers-reduced-motion" },
]} />

### Callbacks

<PropTable items={[
  { name: "onActiveChange", type: "(id: string | null, prevId: string | null) => void", description: "Called when active section changes" },
  { name: "onSectionEnter", type: "(id: string) => void", description: "Called when a section enters the viewport" },
  { name: "onSectionLeave", type: "(id: string) => void", description: "Called when a section leaves the viewport" },
  { name: "onScrollStart", type: "() => void", description: "Called when scrolling starts" },
  { name: "onScrollEnd", type: "() => void", description: "Called when scrolling stops" },
]} />

### Return Value

<PropTable items={[
  { name: "activeId", type: "string | null", description: "ID of the currently active section" },
  { name: "activeIndex", type: "number", description: "Index of the active section in sectionIds (-1 if none)" },
  { name: "scroll", type: "ScrollState", description: "Global scroll state" },
  { name: "sections", type: "Record<string, SectionState>", description: "Per-section state indexed by ID" },
  { name: "sectionProps", type: "(id: string) => SectionProps", description: "Props to spread on section elements" },
  { name: "navProps", type: "(id: string) => NavProps", description: "Props to spread on nav items" },
  { name: "registerRef", type: "(id: string) => (el: HTMLElement | null) => void", description: "Manual ref registration" },
  { name: "scrollToSection", type: "(id: string) => void", description: "Programmatically scroll to a section" },
]} />

## Types

### ScrollState

Global scroll information updated on every scroll event.

```ts
type ScrollState = {
  y: number                        // Current scroll position in pixels
  progress: number                 // Overall scroll progress (0-1)
  direction: 'up' | 'down' | null  // Scroll direction
  velocity: number                 // Scroll speed
  isScrolling: boolean             // True while actively scrolling
  maxScroll: number                // Maximum scroll value
  viewportHeight: number           // Viewport height in pixels
  offset: number                   // Effective trigger offset
}
```

### SectionState

Per-section state available for each tracked section.

```ts
type SectionState = {
  bounds: SectionBounds  // Position and dimensions
  visibility: number     // Visibility ratio (0-1)
  progress: number       // Section scroll progress (0-1)
  isInViewport: boolean  // True if any part is visible
  isActive: boolean      // True if this is the active section
}

type SectionBounds = {
  top: number
  bottom: number
  height: number
}
```

## Examples

### With Callbacks

```tsx
const { activeId } = useDomet(sections, null, {
  onActiveChange: (id, prevId) => {
    console.log(`Changed from ${prevId} to ${id}`)
  },
  onSectionEnter: (id) => {
    console.log(`Entered: ${id}`)
  },
})
```

### Using Scroll State

```tsx
const { scroll, sections } = useDomet(sectionIds)

// Global progress bar
<div style={{ width: `${scroll.progress * 100}%` }} />

// Per-section animations
{sectionIds.map(id => (
  <div style={{ opacity: sections[id]?.visibility }} />
))}
```

### Custom Container

```tsx
const containerRef = useRef<HTMLDivElement>(null)
const { activeId } = useDomet(sections, containerRef)

return (
  <div ref={containerRef} style={{ overflow: 'auto', height: '100vh' }}>
    {/* sections */}
  </div>
)
```

### Fine-tuning Behavior

```tsx
useDomet(sections, null, {
  visibilityThreshold: 0.8,  // Require 80% visibility
  hysteresisMargin: 200,     // More resistance to switching
})
```

## Why domet?

This library was born from a real need at work. I wanted a scroll-spy solution that was powerful and completely headless, but above all, extremely lightweight. No bloated dependencies, no opinionated styling, just a hook that does one thing well.

The name **domet** comes from Bosnian/Serbian/Croatian and means "reach" or "range" — the distance something can cover. Pronounced `/ˈdɔ.met/`: stress on the first syllable, open "o", and a hard "t" at the end.

## Support

For issues or feature requests, open an issue on [GitHub](https://github.com/blksmr/domet).


For LLMs, the full documentation is available at [/llms.txt](/llms.txt).

You can also reach out to me on [Twitter](https://x.com/blkasmir).
