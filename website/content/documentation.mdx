---
title: "Domet"
description: "A lightweight scroll spy hook for React"
---
<Demo src="examples/basic" caption="A quick example demonstrating how easy it is to use" />

### Introduction

Domet is a lightweight React hook built for scroll-driven interfaces. Use it for classic scroll-spy, but also for progress indicators, lazy section loading, or any UI that needs reliable section awareness.

Lightweight under the hood: a tight scroll loop and hysteresis for stable, flicker-free section tracking.

For the source code, check out the [GitHub](https://github.com/blksmr/domet).


### Installation
Install the package from your command line.

```bash
npm install domet
```

### Usage
Basic example of how to use the hook.

```tsx showLineNumbers
import { useDomet } from 'domet'

const ids = ['intro', 'features', 'api']

function Page() {
  const { active, register, link } = useDomet({
    ids,
  })

  return (
    <>
      <nav>
        {ids.map(id => (
          <button key={id} {...link(id)}>
            {id}
          </button>
        ))}
      </nav>

      <section {...register('intro')}>...</section>
      <section {...register('features')}>...</section>
      <section {...register('api')}>...</section>
    </>
  )
}
```


### API Reference

### Options

<PropTable items={[
  { name: "ids", type: "string[]", description: "Array of section IDs to track (mutually exclusive with selector)" },
  { name: "selector", type: "string", description: "CSS selector to find sections (mutually exclusive with ids)" },
  { name: "container", type: "RefObject<HTMLElement | null>", default: "undefined", description: "React ref to scrollable container (defaults to window)" },
  { name: "offset", type: "number | `${number}%`", default: "\"8%\"", description: "Trigger offset from top (pixels or viewport percentage)" },
  { name: "throttle", type: "number", default: "10", description: "Throttle delay in milliseconds" },
  { name: "threshold", type: "number", default: "0.6", description: "Minimum visibility ratio (0-1) for section to get priority" },
  { name: "hysteresis", type: "number", default: "150", description: "Score margin to prevent rapid section switching" },
  { name: "behavior", type: "'smooth' | 'instant' | 'auto'", default: "'auto'", description: "Scroll behavior. 'auto' respects prefers-reduced-motion" },
]} />

### Callbacks

<PropTable items={[
  { name: "onActive", type: "(id: string | null, prevId: string | null) => void", description: "Called when active section changes" },
  { name: "onEnter", type: "(id: string) => void", description: "Called when a section enters the viewport" },
  { name: "onLeave", type: "(id: string) => void", description: "Called when a section leaves the viewport" },
  { name: "onScrollStart", type: "() => void", description: "Called when scrolling starts" },
  { name: "onScrollEnd", type: "() => void", description: "Called when scrolling stops" },
]} />

### Return Value

<PropTable items={[
  { name: "active", type: "string | null", description: "ID of the currently active section" },
  { name: "index", type: "number", description: "Index of the active section in ids (-1 if none)" },
  { name: "progress", type: "number", description: "Overall scroll progress (0-1), shortcut for scroll.progress" },
  { name: "direction", type: "'up' | 'down' | null", description: "Scroll direction, shortcut for scroll.direction" },
  { name: "ids", type: "string[]", description: "Resolved section IDs (useful with CSS selector)" },
  { name: "scroll", type: "ScrollState", description: "Full scroll state object" },
  { name: "sections", type: "Record<string, SectionState>", description: "Per-section state indexed by ID" },
  { name: "register", type: "(id: string) => RegisterProps", description: "Props to spread on section elements (includes id, ref, data-domet)" },
  { name: "link", type: "(id: string) => LinkProps", description: "Props to spread on nav items" },
  { name: "scrollTo", type: "(id: string, options?: ScrollToOptions) => void", description: "Programmatically scroll to a section with optional offset and behavior override" },
]} />

### Types

### ScrollState

Global scroll information updated on every scroll event.

```ts showLineNumbers
type ScrollState = {
  y: number                        // Current scroll position in pixels
  progress: number                 // Overall scroll progress (0-1)
  direction: 'up' | 'down' | null  // Scroll direction
  velocity: number                 // Scroll speed
  scrolling: boolean               // True while actively scrolling
  maxScroll: number                // Maximum scroll value
  viewportHeight: number           // Viewport height in pixels
  offset: number                   // Effective trigger offset
}
```

### SectionState

Per-section state available for each tracked section.

```ts showLineNumbers
type SectionState = {
  bounds: SectionBounds  // Position and dimensions
  visibility: number     // Visibility ratio (0-1)
  progress: number       // Section scroll progress (0-1)
  inView: boolean        // True if any part is visible
  active: boolean        // True if this is the active section
  rect: DOMRect | null   // Full bounding rect
}

type SectionBounds = {
  top: number
  bottom: number
  height: number
}
```

### ScrollToOptions

Options for programmatic scrolling.

```ts showLineNumbers
type ScrollToOptions = {
  offset?: number | `${number}%`  // Override trigger offset
  behavior?: 'smooth' | 'instant' | 'auto'  // Override scroll behavior
}
```

### Examples

### With Callbacks

React to section changes with callbacks for analytics, animations, or state updates:

```tsx showLineNumbers
const { active } = useDomet({
  ids: ['intro', 'features', 'api'],
  onActive: (id, prevId) => {
    console.log(`Changed from ${prevId} to ${id}`)
  },
  onEnter: (id) => {
    console.log(`Entered: ${id}`)
  },
})
```

### Using Scroll State

Build progress indicators and scroll-driven animations using the scroll state:

```tsx showLineNumbers
const { progress, sections, ids } = useDomet({
  ids: ['intro', 'features', 'api'],
})

// Global progress bar
<div style={{ width: `${progress * 100}%` }} />

// Per-section animations
{ids.map(id => (
  <div style={{ opacity: sections[id]?.visibility }} />
))}
```

### Custom Container

Track scroll within a specific container instead of the window:

```tsx showLineNumbers
const containerRef = useRef<HTMLDivElement>(null)

const { active, register } = useDomet({
  ids: ['s1', 's2'],
  container: containerRef,
})

return (
  <div ref={containerRef} style={{ height: '100vh', overflow: 'auto' }}>
    <section {...register('s1')}>Section 1</section>
    <section {...register('s2')}>Section 2</section>
  </div>
)
```

### Third-party Components

If a third-party component only accepts a `ref` prop (no spread), extract the ref from `register`:

```tsx
<ThirdPartyComponent ref={register('section-1').ref} />
```

### CSS Selector for Sections

Instead of passing an array of IDs, you can use the `selector` prop to automatically find sections:

```tsx showLineNumbers
const { active, ids } = useDomet({
  selector: '[data-section]',  // CSS selector
})

// ids will contain IDs from:
// 1. element.id
// 2. data-domet attribute
// 3. fallback: section-0, section-1, etc.
```

### Fine-tuning Behavior

Adjust sensitivity and stability of section detection:

```tsx showLineNumbers
useDomet({
  ids: ['intro', 'features'],
  threshold: 0.8,    // Require 80% visibility
  hysteresis: 200,   // More resistance to switching
})
```

### Why domet?

This library was born from a real need at work. I wanted a scroll-spy solution that was powerful and completely headless, but above all, extremely lightweight. No bloated dependencies, no opinionated styling, just a hook that does one thing well.


Why a hook instead of a component wrapper? Because hooks give you full control. You decide the markup, the styling, and the behavior. If you want a `<ScrollSpy>` component, you can build one in minutes on top of `useDomet`. The hook stays minimal; you compose what you need.

The name **domet** comes from Bosnian/Serbian/Croatian and means "reach" or "range" — the distance something can cover. Pronounced `/ˈdɔ.met/`: stress on the first syllable, open "o", and a hard "t" at the end.

### Support

For issues or feature requests, open an issue on [GitHub](https://github.com/blksmr/domet).


For LLMs, the full documentation is available at [/llms.txt](/llms.txt).

You can also reach out to me on [Twitter](https://x.com/blkasmir).
